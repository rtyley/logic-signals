package com.madgag.logic.fileformat.vcd

import com.madgag.logic.Time.Delta
import ValueChangeDump.DataSection.{ValueChange, dataSection}
import ValueChangeDump.Header.{TimeScale, header}
import ValueChangeDump.{DataSection, Header}
import com.madgag.logic.ChannelSignals

import java.time.Duration
import java.time.temporal.ChronoUnit
import java.time.temporal.ChronoUnit.{MICROS, MILLIS, NANOS, SECONDS}
import scala.collection.immutable.SortedMap


case class ValueChangeDump(
  header: Header,
  dataSection: DataSection
) {
  def channelSignals: ChannelSignals[Delta, String] = ChannelSignals.from(
    SortedMap.from(for {
      (timestamp, valueChangeByChannel) <- dataSection.mergedChangesByTime
    } yield header.timescale.duration.multipliedBy(timestamp) -> valueChangeByChannel)
  ).mapKeys(header.scope.mapping)
}

/**
 * Value Change Dump (VCD) is an ASCII-based format for dumpfiles generated by logic simulation tools.
 * https://en.wikipedia.org/wiki/Value_change_dump
 */
object ValueChangeDump {

  import fastparse.*
  import NoWhitespace.*

  def parser[$: P]: P[ValueChangeDump] = P(header ~ dataSection).map(ValueChangeDump.apply)

  def Newline[$: P] = P( NoTrace(StringIn("\r\n", "\n")) )


  def signalId[$: P]: P[String] = P(CharsWhileIn("!-~").!)

  case class Header(version: String, timescale: TimeScale, scope: Header.Scope)
  object Header {
    def end[$: P] = P(" $end" ~ "\n".?)

    def headerName[$: P](name: String): P[Unit] = P("$" + name + " ")

    def elem[$: P, T](name: String, p: => P[T]): P[T] = P(headerName(name) ~ p ~ end)

    def freeFormatHeader[$: P](name: String): P[String] =
      P(headerName(name) ~ (!end ~ AnyChar).rep().! ~ end)

    trait HeaderElement

    case class Scope(name: String, vars: Seq[VarDef]) extends HeaderElement {
      val mapping: Map[String, String] = vars.map(v => v.id -> v.name).toMap
    }
    case class TimeScale(duration: Duration) extends HeaderElement
    case object OtherHeaderElement extends HeaderElement

    case class VarDef(bitWidth: Int, id: String, name: String)

    def timeunit[$: P]: P[ChronoUnit] = {
      def seconds[$1: P]: P[ChronoUnit] = P("s").map(_ => SECONDS)
      def millis[$1: P]: P[ChronoUnit] = P("ms").map(_ => MILLIS)
      def microseconds[$1: P]: P[ChronoUnit] = P("us").map(_ => MICROS)
      def nanoseconds[$1: P]: P[ChronoUnit] = P("ns").map(_ => NANOS)

      P(seconds | millis | microseconds | nanoseconds)
    }

    def timescale[$: P]: P[TimeScale] =
      elem("timescale", (int ~ timeunit).map(x => TimeScale(Duration.of(x._1, x._2))))

    def signalName[$: P]: P[String] = P(CharsWhileIn("a-zA-Z0-9_").!)

    def varDef[$: P]: P[VarDef] =
      elem("var", ("wire " ~ int ~ " " ~ signalId  ~ " " ~ signalName).map(VarDef.apply))

    def scope[$: P]: P[Scope] =
      (elem("scope", "module " ~ signalName) ~ varDef.rep() ~ ("$upscope" ~ end)).map(Scope.apply)

    def version[$: P]: P[String] = freeFormatHeader("version")
    def date[$: P]: P[Unit] = freeFormatHeader("date")

    def endDefinitions[$: P]: P[Unit] = P("$enddefinitions" ~ end)
    
    def header[$: P]: P[Header] = P( version ~ date ~ timescale ~ scope ~ endDefinitions).map(Header.apply)
  }

  case class DataSection(valueChanges: Seq[ValueChange]) {
    val mergedChangesByTime: Map[Long, Map[String, Boolean]] =
      valueChanges.groupMapReduce(_.timestamp)(_.valueMap)(_ ++ _)
  }

  object DataSection {
    case class VarValue(value: Int, id: String)
    case class ValueChange(timestamp: Long, varValues: Seq[VarValue]) {
      lazy val valueMap: Map[String, Boolean] = varValues.map(x => x.id -> (x.value == 1)).toMap
    }

    def timestamp[$: P]: P[Long] = P( "#" ~ long ~ "\n")
    def varValue[$: P]: P[VarValue] = P( int ~ signalId ~ "\n").map(VarValue.apply)

    def valueChange[$: P]: P[ValueChange] = P(timestamp ~ varValue.rep()).map(ValueChange.apply)

    def dataSection[$: P]: P[DataSection] = P( valueChange.rep() ).map(DataSection.apply)

  }

  def headerName[$: P] = P( CharsWhileIn("a-z").! )

  def int[$: P]: P[Int] = P( CharsWhileIn("0-9").!.map(_.toInt) )
  def long[$: P]: P[Long] = P( CharsWhileIn("0-9").!.map(_.toLong) )

}
